<!DOCTYPE html>
<html lang="ko">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="initial-scale=1, width=device-width">
	<link rel="stylesheet" href="./index.css" />
	<link rel="stylesheet"
		href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;700;900&display=swap" />
	<title>어디갈래? — 프로젝트 상세</title>
	<style>
		/* 헬퍼만 추가 (디자인 영향 최소화) */
		.stack-table {
			width: 100%;
			border-collapse: collapse;
		}

		.stack-table th,
		.stack-table td {
			border: 1px solid #e5e7eb;
			padding: 8px 10px;
			text-align: left;
		}

		.stack-table thead th {
			background: #f8fafc;
		}

		.subheading {
			font-weight: 700;
			margin: 8px 0;
		}

		.mono {
			font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
		}

		.content-img {
			max-width: 100%;
			height: auto;
			display: block;
			margin: 8px 0;
		}
	</style>
</head>

<body>
	<div class="project-detail-view">
		<div class="container">
			<!-- 헤더 카드 -->
			<div class="project-card">
				<div class="wrapper">
					<div class="favicon">
						<div class="favicon-child favicon-whereshouldwego"></div>
					</div>
					<div class="wrapper1">
						<b class="b">어디갈래?</b>
						<div class="calendar-wrapper">
							<img class="icon-frame" alt="" src="/assets/calender_icon.svg">
							<div class="xxxxx-202xxxxx">2025.07.14 ~ 2025.08.22</div>
						</div>
					</div>
				</div>
				<div class="wrapper2">
					<div class="tag">
						<img class="phosphor-icons-users" alt="" src="/assets/user_blue_icon.svg">
						<div class="tag1">참여 인원 | 6명</div>
					</div>
					<div class="tag2">
						<img class="phosphor-icons-users" alt="" src="/assets/lightning_blue_icon.svg">
						<div class="tag1">대표 성과 | 실시간 지도·채팅·추천·투표 통합</div>
					</div>
				</div>
				<div class="link-wrapper">
					<div class="wrapper3" id="buttonContainer" data-href="https://github.com/whereshouldwego/was"
						role="link" tabindex="0" aria-label="Git 저장소 열기">
						<img class="mdigithub-icon" alt="" src="/assets/github_blue_icon.svg">
						<div class="github">Github</div>
						<img class="feather-icons-arrow-up-right" alt="" src="/assets/arrow_up_right_blue_icon.svg">
					</div>
					<div class="wrapper3" id="buttonContainer"
						data-href="https://band-cheddar-f06.notion.site/22aefa246e29804ea730f6f523c3050d?source=copy_link"
						role="link" tabindex="0" aria-label="Notion 문서 열기">
						<img class="mdinotion-icon" alt="" src="/assets/notion_blue_icon.svg">
						<div class="github">Notion</div>
						<img class="feather-icons-arrow-up-right" alt="" src="/assets/arrow_up_right_blue_icon.svg">
					</div>
				</div>
			</div>

			<!-- 본문 -->
			<div class="body-contents-wrapper">

				<!-- 1. 프로젝트 개요 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol">
							<li>프로젝트 개요</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">

							<div class="subheading">기획 배경</div>
							<ul class="ul">
								<li>약속 장소를 정할 때 지도·메신저·투표가 흩어져 맥락이 끊기고 결정이 느립니다. 같은 화면에서 <b>지도 탐색·채팅·추천·투표</b>를 동시에
									처리하고, 채팅 맥락과 리뷰 태그까지 반영하는 흐름이 필요하다고 판단했습니다.</li>
							</ul>
							<br>

							<div class="subheading">프로젝트 목표</div>
							<ul class="ul">
								<li><b>지도 공유 + 실시간 채팅 + 장소 추천·투표</b>를 하나의 서비스로 통합합니다.</li>
								<li>채팅 내역 기반 <b>맞춤형 장소 추천</b>을 제공합니다.</li>
								<li>지도 위에 <b>리뷰 기반 해시태그(분위기/목적 등)</b>를 시각화합니다.</li>
								<li>사용자는 장소를 <b>찜</b>하여 추후 열람할 수 있습니다.</li>
							</ul>
							<br>

							<div class="subheading">팀 구성</div>
							<ul class="ul">
								<li>6인 (FE 3 · BE 2 · <b>BE/Infra 1[본인]</b>)</li>
							</ul>
							<br>

							<div class="subheading">주요 기능</div>
							<ul class="ul">
								<li><b>방 생성 및 초대:</b> 사용자가 방을 만들고 초대 링크를 공유해 실시간 협업 가능</li>
								<li><b>지도 + 채팅 통합 뷰:</b> 지도 화면 옆에 채팅창을 두어 탐색과 소통을 동시에 진행</li>
								<li><b>추천 봇:</b> 사용자가 입력한 조건 또는 채팅 내용 기반으로 맞춤 장소 추천</li>
								<li><b>협업형 지도 탐색:</b> 참여자들이 실시간으로 검색·탐색한 장소를 공유</li>
								<li><b>투표 및 ‘찜’ 기능:</b> 후보 장소 투표 진행 및 ‘찜’으로 추후 열람 가능</li>
								<li><b>리뷰 기반 해시태그 제공:</b> 가게 분위기, 방문 목적 등 후기를 해시태그로 시각화</li>
							</ul>
							<br>

							<div class="subheading">아키텍처</div>
							<figure class="img-card">
								<img class="image lightboxable" src="/assets/whereshouldwego/architecture.png"
									alt="WhereShouldWeGo 서비스 아키텍처 다이어그램" loading="lazy">
								<figcaption class="sr-only">
									WhereShouldWeGo 서비스 아키텍처 다이어그램
								</figcaption>
							</figure>
							<br>

							<div class="subheading">기술 스택</div>
							<table class="stack-table">
								<thead>
									<tr>
										<th>분야</th>
										<th>기술 스택</th>
										<th>설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>프론트엔드</td>
										<td><span class="badge">React(Vite)</span> <span class="badge">TypeScript</span>
											<span class="badge">STOMP.js</span>
										</td>
										<td>지도·채팅 통합 UI, 실시간 구독/발행, 초대 UX</td>
									</tr>
									<tr>
										<td>백엔드 (REST)</td>
										<td><span class="badge strong">Spring Boot</span> <span class="badge">Spring
												Security</span> <span class="badge">FastAPI</span></td>
										<td>REST API 서비스, 인증·권한</td>
									</tr>
									<tr>
										<td>백엔드 (실시간)</td>
										<td><span class="badge strong" >Spring WebSocket</span> <span class="badge strong">STOMP</span>
											<span class="badge strong">SimpleBroker</span>
										</td>
										<td>채팅/후보/투표 라우팅, JWT Handshake</td>
									</tr>
									<tr>
										<td>데이터베이스</td>
										<td><span class="badge strong">PostgreSQL</span> <span
												class="badge strong">MongoDB</span></td>
										<td>운영 데이터, 채팅 로그 저장</td>
									</tr>
									<tr>
										<td>인프라</td>
										<td><span class="badge strong">Docker/Compose</span> <span
												class="badge strong">Nginx</span> <span class="badge strong">Jenkins</span>
											<span class="badge strong">EC2</span>
										</td>
										<td>배포 자동화, 라우팅, 컨테이너 오케스트레이션</td>
									</tr>
									<tr>
										<td>협업</td>
										<td><span class="badge strong">GitLab</span> <span
												class="badge strong">Mattermost</span> <span class="badge strong">Jira</span>
										</td>
										<td>형상 관리, 실시간 협업, 일정 관리</td>
									</tr>
								</tbody>
							</table>
							<br>


							<div class="subheading">시연</div>
							<div class="demo-grid">
								<div class="project-card">
									<video class="video lightboxable" autoplay loop muted playsinline preload="metadata"
										poster="/assets/whereshouldwego/커서공유기능.jpg">
										<source src="/assets/whereshouldwego/커서공유기능.mp4" type="video/mp4" />
										브라우저가 video 태그를 지원하지 않습니다.
									</video>
								</div>
								<div class="project-card">
									<video class="video lightboxable" autoplay loop muted playsinline preload="metadata"
										poster="/assets/whereshouldwego/핀공유기능.jpg">
										<source src="/assets/whereshouldwego/핀공유기능.mp4" type="video/mp4" />
										브라우저가 video 태그를 지원하지 않습니다.
									</video>
								</div>
								<div class="project-card">
									<video class="video lightboxable" autoplay loop muted playsinline preload="metadata"
										poster="/assets/whereshouldwego/실시간채팅.jpg">
										<source src="/assets/whereshouldwego/실시간채팅.mp4" type="video/mp4" />
										브라우저가 video 태그를 지원하지 않습니다.
									</video>
								</div>
								<div class="project-card">
									<video class="video lightboxable" autoplay loop muted playsinline preload="metadata"
										poster="/assets/whereshouldwego/후보지선정기능.jpg">
										<source src="/assets/whereshouldwego/후보지선정기능.mp4" type="video/mp4" />
										브라우저가 video 태그를 지원하지 않습니다.
									</video>
								</div>
							</div>

						</div>
					</div>
				</div>

				<!-- 2. 역할 및 기여도 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="2">
							<li>역할 및 기여도</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">
							<ul class="ul">
								<li><b>실시간 통신 뼈대 설계/구현</b>: STOMP(채팅/후보)와 Raw WebSocket(커서)로 분리했습니다.</li>
								<li><b>인증/입장 제어</b>: 연결 시 <b>JWT 확인</b>, 세션 당 <b>1개 방만 허용</b>했습니다.</li>
								<li><b>채팅·후보 API</b>: 채팅은 <b>MongoDB 저장/조회</b>, 후보·투표는 <b>PostgreSQL 집계/정렬</b>로 나눴습니다.
								</li>
								<li><b>배포 자동화</b>: Jenkins 파이프라인과 Docker Compose로 <b>교체 배포</b>를 만들었습니다.</li>
							</ul>
						</div>
					</div>
				</div>

				<!-- 3. 개발 상세 내용 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="3">
							<li>개발 상세</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">
							<details>
								<summary><b>3.1. STOMP 기반 실시간 채팅 및 실시간 후보 공유</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>서비스는 사용자가 한 화면에서 <b>채팅, 후보 등록, 투표</b>를 동시에 진행할 수 있어야 했습니다.</li>
										<li>사용자 경험을 위해 지연은 최소화해야 했고, 방(Room) 단위로 접근을 제한할 수 있어야 했습니다.</li>
										<li>데이터 성격에 따라 채팅은 빠른 쓰기/조회, 후보·투표는 집계·정렬이 핵심이었습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>같은 방에서 여러 유형의 메시지가 동시에 오가므로 <b>주제별 분리</b>가 필요했습니다.</li>
										<li>방 단위로 <b>저지연 브로드캐스트</b>를 지원하면서도, 입장/구독 시점에 <b>정확한 인증·권한 제어</b>가 요구되었습니다.
										</li>
										<li>데이터 저장소 선택도 문제였습니다. 채팅은 로그 성격이라 빠른 쓰기/조회가 중요하고, 후보·투표는 집계 성능이 더 중요했습니다.</li>
									</ul>

									<h4>해결 방안</h4>

									<figure class="img-card">
										<img class="image lightboxable"
											src="/assets/whereshouldwego/sequence_diagram_stomp.png"
											alt="WhereShouldWeGo sequence_diagram_stomp" loading="lazy">
										<figcaption class="sr-only">
											WhereShouldWeGo sequence_diagram_stomp
										</figcaption>
									</figure>

									<ul class="ul">
										<li><b>STOMP(Simple Text Oriented Messaging Protocol) 채택</b>
											<ul>
												<li>브라우저/WebSocket 호환성이 높고, 토픽 기반 메시지 분리에 적합하여 선택하였습니다.</li>
											</ul>
											<pre><code>SEND : /app/chat.{roomCode}</code></pre>
											<pre><code>SUB  : /topic/chat.{roomCode}</code></pre>
											<pre><code>SEND : /app/candidate.{roomCode}</code></pre>
											<pre><code>SUB  : /topic/candidate.{roomCode}</code></pre>
										</li>
										<li><b>세션 인증 및 접근 제어</b>
											<ul>
												<li><code>StompAuthInterceptor</code>를 구현하여 <b>CONNECT</b> 단계에서 토큰을 검증하고
													사용자 인증을 주입하였습니다.</li>
												<li><b>SUBSCRIBE</b> 단계에서는 <code>roomCode → roomId</code> 매핑 후,
													<code>existsByRoomIdAndUserId</code>로 멤버십을 검증하였습니다.
												</li>
												<li><b>SEND</b> 단계에서는 세션이 속한 방과 목적지 방이 일치할 때만 메시지를 허용하였습니다.</li>
												<li><b>DISCONNECT</b> 시 세션 상태를 정리하여 불필요한 자원 점유를 방지하였습니다.</li>
											</ul>
										</li>
										<li><b>세션 구조 단순화</b>
											<ul>
												<li>“한 소켓 = 한 방”으로 제한하여 관리 복잡도를 줄이고, 잘못된 구독/전송을 사전에 차단하였습니다.</li>
											</ul>
										</li>
										<li><b>데이터 저장소 분리 설계</b>
											<ul>
												<li>채팅: <b>MongoDB</b>에 저장 (컬렉션: <code>Chat</code>, 인덱스
													<code>roomCode, createdAt</code>) → 빠른 쓰기/조회에 최적화하였습니다.
												</li>
												<li>후보/투표: <b>PostgreSQL</b> (<code>Candidate</code>, <code>Vote</code>)
													→ 집계와 정렬 성능을 극대화하였습니다.</li>
												<li>사용자가 입장할 때는 REST API로 과거 채팅·후보 기록을 불러와 UI를 초기화하였습니다.</li>
											</ul>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>평균 지연 시간을 <b>100ms 이하</b>로 유지해 실시간성을 확보했습니다.</li>
										<li>동시 접속자 <b>50명 이상</b> 환경에서도 안정적으로 동작하는 것을 확인했습니다.</li>
										<li>데이터 성격에 맞는 저장소 분리로 조회 성능이 개선되어, 후보 집계 응답 속도가 <b>약 40% 향상</b>되었습니다.</li>
									</ul>
								</div>
							</details>


							<details>
								<summary><b>3.2. WebSocket 기반 실시간 마우스 커서 공유</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>지도 기반 협업에서는 각 사용자가 어떤 영역을 보고 있는지 파악하는 것이 중요합니다.</li>
										<li>이를 위해 <b>마우스 커서 공유 기능</b>이 필요했으며, 이는 사용자 간 의사소통 효율을 크게 높일 수 있습니다.</li>
										<li>하지만 커서 위치 이벤트는 초당 수십 건 이상 발생하는 <b>고빈도 이벤트</b>이므로, 채팅과 동일한 STOMP 기반 프로토콜로
											처리하면 불필요한 오버헤드가 발생합니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li><b>지연 최소화</b>: 커서 이벤트는 수십 ms 단위로 동기화되어야 하므로, 전송·브로드캐스트 과정에서 오버헤드를 최소화해야
											했습니다.</li>
										<li><b>인증과 세션 관리</b>: 방 단위로만 접근을 허용하고, 중복 연결이나 세션 누수를 막기 위해 <b>Handshake 인증과 세션
												정리</b>가 필요했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<figure class="img-card">
										<img class="image lightboxable"
											src="/assets/whereshouldwego/sequence_diagram_websocket.png"
											alt="WhereShouldWeGo sequence_diagram_websocket" loading="lazy">
										<figcaption class="sr-only">
											WhereShouldWeGo sequence_diagram_websocket
										</figcaption>
									</figure>

									<ul class="ul">
										<li><b>Raw WebSocket 채택</b>
											<ul>
												<li>STOMP보다 경량화된 양방향 통신 프로토콜로, 불필요한 헤더 없이 순수 텍스트/바이너리 메시지를 송수신할 수 있습니다.
												</li>
												<li>고빈도·저용량 이벤트 전송에 적합하여 커서 위치 공유에 최적입니다.</li>
												<li>엔드포인트는 <code>/ws-raw/cursor?roomCode=...&amp;token=Bearer…</code>로
													정의하였습니다.</li>
											</ul>
										</li>
										<li><b>인증·인가 처리</b>
											<ul>
												<li>Handshake 단계에서 토큰·roomCode를 검증한 뒤,
													<code>roomId, userId, nickname, auth</code>를 세션 Attribute로 저장하였습니다.
												</li>
												<li><code>existsByRoomIdAndUserId</code> 검증을 통과한 사용자만 연결을 허용하였습니다.</li>
											</ul>
										</li>
										<li><b>세션 관리 및 브로드캐스트</b>
											<pre><code>roomSessions : roomCode -> Set&lt;WebSocketSession&gt;</code></pre>
											<pre><code>sessionRoomMap : sessionId -> roomCode</code></pre>
											<ul>
												<li>비동기 <code>TaskExecutor</code>를 통해 송신을 처리하고, 세션 단위
													동기화(<code>synchronized(session)</code>)로 안전하게 전송하였습니다.</li>
												<li>중복 접속 차단을 위해 <code>(roomId:userId)</code> 단위로 레지스트리에 등록하고, 새 연결이 오면
													기존 세션을 <b>POLICY_VIOLATION</b> 코드로 종료하였습니다.</li>
											</ul>
										</li>
										<li><b>STOMP와의 싱크</b>
											<ul>
												<li>STOMP <code>DISCONNECT</code> 이벤트에서 <code>(roomId,userId)</code>를
													확인하고, <code>RawWebSocketSessionRegistry.closeIfPresent</code>를 호출하여
													Raw WS 세션도 자동 종료되도록 하였습니다.</li>
											</ul>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>커서 위치를 <b>50ms 단위로 안정적으로 동기화</b>하여 사용자가 지도 상에서 실시간으로 협업할 수 있었습니다.</li>
										<li>STOMP 채널(채팅/후보)과 분리되어, 고빈도 커서 트래픽이 다른 기능 성능에 영향을 주지 않았습니다.</li>
										<li>세션 관리·중복 접속 제어를 통해 안정성을 확보하였으며, 동시 사용자 환경에서도 성능 저하 없이 동작하였습니다.</li>
									</ul>
								</div>
							</details>


							<details>
								<summary><b>3.3. Infra 구축</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>서비스는 AWS EC2(16GB 디스크) 한 대에서 운영해야 했습니다.</li>
										<li>Spring Boot 백엔드, React 프론트엔드, Nginx, MongoDB(채팅 저장), Jenkins, PostgreSQL 등을
											모두 같은 인스턴스에서 띄워야 했습니다.</li>
										<li>또한 서비스 특성상 <b>장소 데이터와 장소 벡터 데이터</b>를 저장해야 하므로, 데이터베이스 용량 사용량이 클 것으로 예상되었습니다.
										</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>제한된 디스크(16GB)에서 모든 서비스와 데이터 저장소를 동시에 운영할 경우, <b>용량 부족</b> 및 <b>성능 저하</b>
											가능성이 있었습니다.</li>
										<li>초기 사용자 수는 적었지만, 향후 확장 가능성을 유지하면서도 <b>불필요한 외부 서비스 도입으로 인한 리소스 낭비를 방지</b>해야
											했습니다.</li>
										<li>실시간 기능 구현을 위해 <b>메시지 브로커(RabbitMQ, Redis Pub/Sub 등) 사용 여부</b>도 판단해야 했습니다.
										</li>
									</ul>

									<h4>해결 방안</h4>
									<ul class="ul">
										<li>데이터베이스 부하와 디스크 점유를 줄이기 위해 <b>AWS RDS를 별도로 구축하여 PostgreSQL을 외부로 분리하였습니다.</b>
										</li>
										<li>EC2에는 MongoDB만 남겨 채팅 기록을 저장하고, 대용량 장소 데이터와 벡터 데이터는 RDS에 저장하였습니다.</li>
										<li>실시간 메시징은 <b>Spring Simple Broker</b>를 사용하여 EC2 내부에서 처리하였습니다.</li>
										<li>초기 트래픽이 낮고 메시지 영속성이 필수적이지 않으므로, RabbitMQ나 Redis와 같은 외부 브로커는 도입하지 않았습니다.</li>
										<li>모든 서비스는 <b>Docker Compose로 컨테이너화</b>하여 관리하였고, 필요 시 개별 서비스의 재시작이나 확장이 가능하도록
											설계하였습니다.</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>PostgreSQL을 RDS로 분리함으로써 <b>EC2 디스크 점유율을 크게 줄이고 운영 복잡도를 낮출 수 있었습니다.</b></li>
										<li>외부 브로커를 도입하지 않고도 초기 요구사항을 충족하였으며, 필요 시 수평 확장이 가능한 구조를 확보하였습니다.</li>
									</ul>
								</div>
							</details>


							<details>
								<summary><b>3.4. CI/CD 구축</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>프로젝트는 GitLab 저장소에서 진행되었으며, 제공된 EC2 서버에 배포해야 했습니다.</li>
										<li>원래는 GitLab CI/CD를 활용할 수 있었지만, 교육 환경에서 해당 기능이 차단되어 사용할 수 없었습니다.</li>
										<li>따라서 EC2에 Docker 기반 Jenkins를 띄우고, 빌드·배포 자동화를 직접 구성해야 했습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>GitLab CI/CD를 사용할 수 없었기 때문에, <b>외부에서 브랜치 감지, 빌드, 배포를 모두 처리</b>해야 했습니다.</li>
										<li>Jenkins와 운영 서버(EC2)가 동일 환경에 존재하여, 빌드 과정과 운영 서비스 간 <b>리소스 충돌 가능성</b>이 있었습니다.
										</li>
										<li>프론트엔드와 백엔드가 각각 다른 GitLab 브랜치(<code>develop/front</code>,
											<code>develop/back</code>)에 있어 <b>동시에 빌드·배포</b>가 필요했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<ul class="ul">
										<li>EC2에 Docker 기반 Jenkins 컨테이너를 실행하였습니다.</li>
										<li>Jenkins Pipeline을 작성하여 다음 절차를 자동화하였습니다.
											<ol>
												<li><b>FE/BE 병렬 처리</b>
													<ul>
														<li>각 브랜치를 GitLab에서 clone하였습니다.</li>
														<li>Dockerfile 기반 멀티 스테이지 빌드를 수행하였습니다.</li>
														<li>빌드 산출물 이미지를 Docker Hub에 푸시하였습니다.</li>
													</ul>
												</li>
												<li><b>배포 서버 업데이트</b>
													<ul>
														<li>Jenkins에서 EC2 로컬의 <code>docker-compose.yml</code>을 유지하였습니다.
														</li>
														<li>새로운 이미지로 <code>docker compose pull</code> 후,
															<code>docker compose up -d</code>를 실행하여 교체 배포하였습니다.</li>
													</ul>
												</li>
												<li><b>보안 관리</b>
													<ul>
														<li>Jenkins Credentials를 통해 API Key, Docker Hub 계정 등 민감 정보를 안전하게
															주입하였습니다.</li>
													</ul>
												</li>
											</ol>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>GitLab CI/CD 없이도 EC2 단일 서버 환경에서 <b>빌드·배포 자동화</b>를 구현할 수 있었습니다.</li>
										<li>FE/BE 병렬 빌드를 적용하여 전체 파이프라인 시간을 <b>약 40% 단축</b>하였습니다. (빌드 로그 기준)</li>
										<li>Docker Hub와 Compose를 활용하여 배포 다운타임을 <b>수 초 이내</b>로 줄였으며, 롤백도 즉시 가능하게 하였습니다.
										</li>
									</ul>
								</div>
							</details>

						</div>
					</div>
				</div>


				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="4">
							<li>회고</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">
							<ul class="ul">
								<li><b>기술 선택의 트레이드오프 체감</b>: 단일 서버 환경에서 Redis나 RabbitMQ 대신 SimpleBroker를 채택해 초기 트래픽 요구에는
									충분했지만, 확장성 한계를 직접 경험했습니다. 트래픽 수준에 따라 아키텍처를 유연하게 바꿔야 한다는 점을 배웠습니다.</li>
								<li><b>데이터 특성에 맞는 저장소 분리</b>: 채팅 로그는 MongoDB, 투표/후보는 PostgreSQL로 나누어 처리하며, 데이터 성격에 따라
									저장소를 구분해야 성능과 관리 효율을 동시에 확보할 수 있음을 배웠습니다.</li>
								<li><b>운영 환경 제약 속 문제 해결</b>: 16GB 디스크 제한, GitLab CI/CD 차단 등 제약 조건 속에서 Jenkins+Docker
									Compose로 배포 자동화를 구축하며, 완벽한 이상형 아키텍처보다 주어진 자원 안에서 안정적이고 재현 가능한 구조 설계가 중요함을 느꼈습니다.
								</li>
								<li><b>협업과 문서화의 가치</b>: 실시간 기능 설계를 다이어그램·노션 문서로 공유하면서 팀원 간 이해도가 높아졌고, 유지보수가 수월해졌습니다.
									협업에서는 문서화와 시각화가 핵심임을 배웠습니다.</li>
							</ul>
						</div>
					</div>
				</div>


				<!-- 하단 버튼 -->
				<div class="btn-wrapper">
					<div class="button" id="buttonContainer" data-href="../../index.html" role="link" tabindex="0"
						aria-label="목록으로 돌아가기">
						<img class="phosphor-icons-users" alt="" src="/assets/caret_left_icon.svg">
						<div class="button1">돌아가기</div>
					</div>
				</div>
			</div>
		</div>
		<div class="sticky">
			<div class="text-wrapper">
				<div class="div7">협업은 부드럽게, 기준은 단단하게.</div>
				<b class="b8">신입 데이터 엔지니어 황동혁입니다.</b>
			</div>
			<div class="wrapper12">
				<div class="button2" id="buttonContainer" data-href="../../index.html" role="link">
					<img class="phosphor-icons-caretleft1" alt="" src="/assets/caret_left_icon.svg">

				</div>
				<b class="b9">프로젝트 상세보기</b>
			</div>
		</div>

		<script>
			document.querySelectorAll('[id="buttonContainer"]').forEach((btn) => {
				const url = btn.dataset.href || './index.html';
				const go = () => { window.location.href = url; };
				btn.addEventListener('click', go);
				btn.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' || e.key === ' ') {
						e.preventDefault();
						go();
					}
				});
			});

			(function () {
				// 오버레이 DOM 생성
				const overlay = document.createElement('div');
				overlay.className = 'lightbox-overlay';
				overlay.innerHTML = `
    <div class="lightbox-content" tabindex="-1" role="dialog" aria-modal="true">
      <button class="lightbox-close" aria-label="닫기">✕</button>
    </div>
  `;
				document.body.appendChild(overlay);

				const content = overlay.querySelector('.lightbox-content');
				const closeBtn = overlay.querySelector('.lightbox-close');

				function getVideoSrc(el) {
					const s = el.querySelector('source');
					return (s && s.src) || el.currentSrc || el.src;
				}

				function openLightbox(el) {
					// 기존 미디어 제거
					content.querySelectorAll('img,video').forEach(n => n.remove());

					let node;
					if (el.tagName.toLowerCase() === 'img') {
						node = document.createElement('img');
						node.src = el.src;
						node.alt = el.alt || '';
					} else {
						node = document.createElement('video');
						node.src = getVideoSrc(el);
						node.autoplay = true;
						node.loop = true;
						node.muted = true;
						node.playsInline = true;
						node.controls = true;
					}

					content.appendChild(node);
					overlay.style.display = 'flex';
					document.body.classList.add('lb-open');
					content.focus();
				}

				function closeLightbox() {
					overlay.style.display = 'none';
					document.body.classList.remove('lb-open');
					content.classList.remove('cover'); // cover 모드 해제
					const v = content.querySelector('video');
					if (v) { try { v.pause(); } catch (e) { } }
				}

				// 위임 클릭으로 열기
				document.addEventListener('click', (e) => {
					const t = e.target.closest('.lightboxable');
					if (t) {
						e.preventDefault();
						openLightbox(t);
					}
				});

				// 배경 클릭으로 닫기
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) closeLightbox();
				});

				closeBtn.addEventListener('click', closeLightbox);

				// ESC 닫기
				document.addEventListener('keydown', (e) => {
					if (overlay.style.display === 'flex' && e.key === 'Escape') closeLightbox();
				});

				// Z 키 or 미디어 클릭으로 contain ↔ cover 전환
				function toggleFitMode() {
					content.classList.toggle('cover');
				}

				content.addEventListener('click', (e) => {
					const media = e.target.closest('img,video');
					if (media) toggleFitMode();
				});

				document.addEventListener('keydown', (e) => {
					if (overlay.style.display === 'flex' && (e.key === 'z' || e.key === 'Z')) {
						toggleFitMode();
					}
				});
			})();
		</script>

</body>

</html>