<!DOCTYPE html>
<html lang="ko">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="initial-scale=1, width=device-width">
	<link rel="stylesheet" href="./index.css" />
	<link rel="stylesheet"
		href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;700;900&display=swap" />
	<title>KLYDE — 프로젝트 상세</title>
	<style>
		/* 헬퍼만 추가 (디자인 영향 최소화) */
		.stack-table {
			width: 100%;
			border-collapse: collapse;
		}

		.stack-table th,
		.stack-table td {
			border: 1px solid #e5e7eb;
			padding: 8px 10px;
			text-align: left;
		}

		.stack-table thead th {
			background: #f8fafc;
		}

		.subheading {
			font-weight: 700;
			margin: 8px 0;
		}

		.mono {
			font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
		}

		.content-img {
			max-width: 100%;
			height: auto;
			display: block;
			margin: 8px 0;
		}
	</style>
</head>

<body>
	<div class="project-detail-view">
		<div class="container">
			<!-- 헤더 카드 -->
			<div class="project-card">
				<div class="wrapper">
					<div class="favicon">
						<div class="favicon-child favicon-klyde"></div>
					</div>
					<div class="wrapper1">
						<b class="b">KLYDE</b>
						<div class="calendar-wrapper">
							<img class="icon-frame" alt="" src="/assets/calender_icon.svg">
							<div class="xxxxx-202xxxxx">2025.05.22 ~ 2025.05.27</div>
						</div>
					</div>
				</div>
				<div class="wrapper2">
					<div class="tag">
						<img class="phosphor-icons-users" alt="" src="/assets/user_blue_icon.svg">
						<div class="tag1">참여 인원 | 2명</div>
					</div>
					<div class="tag2">
						<img class="phosphor-icons-users" alt="" src="/assets/lightning_blue_icon.svg">
						<div class="tag1">대표 성과 | 실시간 뉴스 파이프라인</div>
					</div>
				</div>
				<div class="link-wrapper">
					<div class="wrapper3" id="buttonContainer" data-href="https://github.com/GomDue/KLYDE.git"
						role="link" tabindex="0" aria-label="Git 저장소 열기">
						<img class="mdigithub-icon" alt="" src="/assets/github_blue_icon.svg">
						<div class="github">Github</div>
						<img class="feather-icons-arrow-up-right" alt="" src="/assets/arrow_up_right_blue_icon.svg">
					</div>
				</div>
			</div>

			<!-- 본문 -->
			<div class="body-contents-wrapper">
				<!-- 1. 프로젝트 개요 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol">
							<li>프로젝트 개요</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">

							<div class="subheading">기획 배경</div>
							<ul class="ul">
								<li>여러 사이트에 흩어진 방대한 뉴스 속에서 <b>개인에게 필요한 기사를 빠르게 찾기 어렵고</b>, 전반 흐름을 파악하기도 쉽지 않았습니다.</li>
								<li>특히 <b>영문 기사 이해 난이도</b>가 높아 소비 장벽이 존재했습니다.</li>
								<li>KLYDE는 이 문제를 <b>추천·요약·번역</b>으로 풀어 사용자가 <b>쉽게 찾고 빠르게 이해</b>하도록 돕고자 했습니다.</li>
							</ul>
							<br>

							<div class="subheading">프로젝트 목표</div>
							<ul class="ul">
								<li>사용자의 관심사에 맞춘 <b>맞춤형 뉴스 제공</b>과 <b>AI 챗봇</b>으로 뉴스 이해를 돕습니다.</li>
								<li>“Clarity + Glide” 철학처럼, <b>핵심 정보를 명료하게 정리</b>하고 <b>매끄럽게 전달</b>하는 경험을 제공합니다.</li>
								<li><b>전면 영어 기반</b> 소스(RSS: BBC, NYT, ZDNet Korea, Nippon 등)를 수집해 글로벌 뉴스를 다룹니다.</li>
							</ul>
							<br>

							<div class="subheading">팀 구성</div>
							<ul class="ul">
								<li>2인 (Full Stack 1 · <b>BE/DE 1[본인]</b>)</li>
							</ul>
							<br>

							<div class="subheading">주요 기능</div>
							<ul class="ul">
								<li><b>실시간 뉴스 수집 및 처리:</b> RSS, Selenium 기반 뉴스 크롤링 → Kafka 실시간 처리</li>
								<li><b>AI 분석 자동화:</b> GPT-4o-mini API 호출로 카테고리 분류, 키워드 추출, 임베딩</li>
								<li><b>다계층 저장소 구성:</b> PostgreSQL(DB), Elasticsearch(검색) 병렬 저장</li>
								<li><b>Elasticsearch 동기화 DAG:</b> PostgreSQL 변경사항을 10분마다 Elasticsearch에 반영</li>
								<li><b>일일 뉴스 분석 리포트:</b> Spark 분석 결과를 PDF로 정리해 이메일 자동 발송 (Airflow + Gmail API)</li>
							</ul>
							<br>

							<div class="subheading">아키텍처</div>
							<figure class="img-card">
								<img class="image lightboxable" src="/assets/klyde/architecture_KLYDE.png"
									alt="KLYDE 서비스 아키텍처 다이어그램" loading="lazy">
								<figcaption class="sr-only">
									KLYDE 서비스 아키텍처 다이어그램
								</figcaption>
							</figure>
							<br>

							<div class="subheading">기술 스택</div>
							<table class="stack-table">
								<thead>
									<tr>
										<th>분야</th>
										<th>기술 스택</th>
										<th>설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>데이터 수집</td>
										<td><span class="badge strong">RSS</span> <span
												class="badge strong">BeautifulSoup</span></td>
										<td>뉴스 본문·메타데이터 수집</td>
									</tr>
									<tr>
										<td>실시간 처리</td>
										<td><span class="badge strong">Kafka</span></td>
										<td>스트리밍 파이프라인 구성</td>
									</tr>
									<tr>
										<td>저장소</td>
										<td><span class="badge strong">PostgreSQL</span> <span
												class="badge">Elasticsearch</span></td>
										<td>운영 DB, 검색 인덱스(전문검색)</td>
									</tr>
									<tr>
										<td>AI 분석</td>
										<td><span class="badge strong">OpenAI GPT-4o-mini</span></td>
										<td>분류·키워드·요약/번역·임베딩</td>
									</tr>
									<tr>
										<td>배치 분석</td>
										<td><span class="badge strong">Apache Spark</span> <span
												class="badge strong">Matplotlib</span></td>
										<td>전일 집계·시각화(PDF 리포트)</td>
									</tr>
									<tr>
										<td>워크플로우</td>
										<td><span class="badge strong">Apache Airflow</span></td>
										<td>일일 리포트·ES 동기화 DAG, Gmail API 발송</td>
									</tr>
									<tr>
										<td>웹</td>
										<td><span class="badge">Django</span> <span class="badge">Vue.js</span></td>
										<td>관리/대시보드 개발</td>
									</tr>
									<tr>
										<td>인프라</td>
										<td><span class="badge strong">Docker Compose</span></td>
										<td>통합 컨테이너 운영</td>
									</tr>
								</tbody>
							</table>
							<br>

							<div class="subheading">시연</div>
							<div class="demo-grid">
								<div class="project-card">
									<figure>
										<img class="video lightboxable" src="/assets/klyde/dashboard.gif" alt="대시보드 시연"
											loading="lazy">
										<figcaption class="sr-only">대시보드 기능 시연</figcaption>
									</figure>
								</div>
								<div class="project-card">
									<figure>
										<img class="video lightboxable" src="/assets/klyde/chatbot.gif" alt="챗봇 시연"
											loading="lazy">
										<figcaption class="sr-only">챗봇 기능 시연</figcaption>
									</figure>
								</div>
								<div class="project-card">
									<figure>
										<img class="video lightboxable" src="/assets/klyde/news-detail-comment.gif"
											alt="뉴스 상세 및 댓글 시연" loading="lazy">
										<figcaption class="sr-only">뉴스 상세 및 댓글 기능 시연</figcaption>
									</figure>
								</div>
								<div class="project-card">
									<figure>
										<img class="video lightboxable" src="/assets/klyde/search-sort.gif"
											alt="검색 및 정렬 시연" loading="lazy">
										<figcaption class="sr-only">검색 및 정렬 기능 시연</figcaption>
									</figure>
								</div>
							</div>


						</div>
					</div>
				</div>

				<!-- 2. 역할 및 기여도 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="2">
							<li>역할 및 기여도</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">
							<ul class="ul">
								<li><b>Kafka Producer/Consumer</b> 설계·구현, 실시간 LLM 파이프라인</li>
								<li>Airflow로 일일 리포트 자동화 및 PostgreSQL ↔ Elasticsearch 동기화</li>
								<li>Docker-compose로 통합 개발환경 구성</li>
							</ul>
						</div>
					</div>
				</div>

				<!-- 3. 개발 상세 — 실시간 파이프라인 구성 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="3">
							<li>개발 상세</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">

							<details>
								<summary><b>3.1. 실시간/배치 파이프라인 구축</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>KLYDE는 실시간으로 뉴스를 수집하고, 분류·키워드 추출·추천까지 제공하는 서비스입니다.</li>
										<li>단순히 DB에 한 번에 저장하는 구조로는 처리 과정 변경이나 기능 확장이 어려워, 단계별로 데이터를 흘려보내며 가공할 수 있는 구조가
											필요했습니다.</li>
										<li>또한 사용자는 검색·추천을 통해 최신 기사를 확인하지만, 내부 운영을 위해서는 매일 <b>전날 뉴스의 집계·분석 리포트</b>도
											필요했습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>실시간 파이프라인에서는 <b>지연 최소화</b>와 함께, 처리 중 <b>중복·유실 방지</b>가 핵심 과제였습니다.</li>
										<li>뉴스 소스가 늘어나더라도 코드 수정 없이 <b>설정 변경만으로 확장 가능</b>해야 했습니다.</li>
										<li>배치 파이프라인에서는 전날 기사를 빠르게 집계하고 시각화하며, 생성된 리포트를 <b>자동 발송</b>까지 이어야 했습니다.</li>
										<li>PostgreSQL과 Elasticsearch 간의 <b>정합성 불일치</b>를 보정할 수 있는 절차도 필요했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<ul class="ul">
										<figure class="img-card">
											<img class="image lightboxable" src="/assets/klyde/data_diagram_klyde.png"
												alt="WhereShouldWeGo 서비스 아키텍처 다이어그램" loading="lazy">
											<figcaption class="sr-only">
												실시간 파이프라인 데이터 흐름
											</figcaption>
										</figure>
										<li><b>실시간 파이프라인 (Kafka 기반)</b>
											<ul>
												<li><b>Kafka 단일 토픽</b>으로 파이프라인을 구성하여 운영 단순성을 확보하였습니다.</li>
												<li><b>Producer</b>: RSS를 파싱 후 본문을 스크레이핑하고, URL 해시를 Key로 JSON 메시지를
													발행하였습니다.</li>
												<li><b>Consumer</b>: auto-commit 기반으로 지연을 줄였고, 기사를 전처리한 뒤
													<b>PostgreSQL</b>에 저장하였습니다. 저장 성공 시 <b>Elasticsearch</b>에 색인하고, 실패
													건은 로그로 추적하도록 하였습니다.
												</li>
												<li><b>LLM 후처리 모듈</b>(키워드 추출·분류·임베딩)은 함수 단위로 분리했습니다. (현재는 비용 문제로 인해 비활성화
													했습니다.)
												</li>
											</ul>
										</li>
										<li><b>배치 분석 및 리포트 자동화</b>
											<ul>
												<li>매일 06:00 KST, <b>Airflow DAG</b>가 실행되어 <b>Spark</b>로 전날 기사를 집계하였습니다.
												</li>
												<li>기사 수·카테고리 분포·시간대 분포·TOP 키워드·Word Cloud 등을 시각화하여 <b>PDF 리포트</b>를
													생성하였습니다.</li>
												<li>리포트는 <b>Gmail API</b>를 통해 수신 동의 사용자에게 자동 발송되었으며, 지표는 데이터 마트 테이블에도
													저장되었습니다.</li>
											</ul>
										</li>
										<li><b>Elasticsearch 동기화</b>
											<ul>
												<li>PostgreSQL의 <code>updated_at</code> 기준으로 변경된 행만 조회하여, 10분 주기로
													<b>Elasticsearch Bulk Upsert</b>를 수행하였습니다.
												</li>
												<li>성공 시 <code>last_sync_ts</code>를 갱신해 증분 동기화를 보장하였고,
													<code>_id = url</code>, <code>doc_as_upsert=true</code> 방식으로 중복 및
													불일치를 최소화하였습니다.
												</li>
											</ul>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>기사 수집 직후 <b>전처리 → DB 저장 → ES 색인</b>까지 평균 <b>3초 이내</b>로 처리하여 실시간성을 확보했습니다.
										</li>
										<li><b>Spark + Airflow</b> 조합으로 대용량 집계와 스케줄링을 안정적으로 처리했습니다.</li>
										<li>매일 생성되는 PDF 리포트를 자동 발송하여, 운영팀의 수작업 리포트 작성 시간을 <b>100% 절감</b>했습니다.</li>
									</ul>
								</div>
							</details>


							<details>
								<summary><b>3.2. 저장 전략(이중 저장)</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>뉴스 데이터는 <b>검색, 추천, 분석</b> 등 서로 다른 접근 패턴을 지원해야 했습니다.</li>
										<li><b>PostgreSQL</b>은 정합성과 SQL 기반 집계에 강점이 있었고, <b>Elasticsearch</b>는 전문 검색과 고속
											질의에 강점이 있었습니다.</li>
										<li>따라서 실시간 처리된 데이터를 <b>두 저장소에 동시에 반영</b>하여 각자의 장점을 활용할 필요가 있었습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>PostgreSQL과 Elasticsearch에 동시에 데이터를 쓰는 과정에서 일시적인 <b>정합성 불일치</b>가 발생할 수
											있었습니다.</li>
										<li>또한 <b>중복 삽입을 방지</b>하고, <b>업데이트 시 일관성</b>을 보장해야 했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<ul class="ul">
										<li><b>PostgreSQL</b>은 원본 데이터 보존, 운영 정합성 유지, 집계 및 통계 질의 최적화를 담당하도록 하였습니다.</li>
										<li><b>Elasticsearch</b>는 전문 검색, 하이라이팅, 추천용 쿼리에 활용하도록 하였습니다.</li>
										<li><b>업서트 키 = URL</b> 방식으로 중복 및 불일치를 최소화하였습니다.
											<ul>
												<li>PostgreSQL: <code>ON CONFLICT (url)</code>을 사용하여 중복 삽입을 방지하였습니다.
												</li>
												<li>Elasticsearch: <code>_id = url</code>과
													<code>doc_as_upsert=true</code> 설정을 사용하여 upsert를 처리하였습니다.
												</li>
											</ul>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li><b>정확한 집계와 빠른 검색</b>이라는 두 가지 요구를 동시에 충족했습니다.</li>
										<li>PostgreSQL은 집계 성능을 보장하고, Elasticsearch는 검색 응답 속도를 <b>수백 ms 수준</b>으로 낮췄습니다.
										</li>
										<li>DB ↔ ES 동기화 절차를 통해 운영 중 발생하는 정합성 문제를 크게 줄였습니다.</li>
									</ul>
								</div>
							</details>


							<details>
								<summary><b>3.3. 뉴스 리포트 자동 생성</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>KLYDE는 실시간 검색·추천을 제공하지만, 내부 운영진은 하루 단위 뉴스 흐름을 요약해 볼 자료가 필요했습니다.</li>
										<li>단순 나열이 아닌 <b>수치·추이·분포·핵심 키워드</b>가 한 페이지로 정리된 리포트가 필요했습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>매일 아침 자동 생성이 필요해 <b>완전 자동화</b>가 요구되었습니다.</li>
										<li><b>추이(14일)</b>, <b>시간대 분포</b>, <b>키워드·카테고리</b> 등 다양한 분석을 한 번에 제공해야 했습니다.
										</li>
										<li>시각화가 많아도 <b>간결하고 직관적</b>이어야 했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<figure class="img-card">
										<img class="image lightboxable" src="/assets/klyde/daily_report_1.jpg"
											alt="WhereShouldWeGo sequence_diagram_stomp" loading="lazy">
									</figure>
									<figure class="img-card">
										<img class="image lightboxable" src="/assets/klyde/daily_report_2.jpg"
											alt="WhereShouldWeGo sequence_diagram_stomp" loading="lazy">
									</figure>
									<figure class="img-card">
										<img class="image lightboxable" src="/assets/klyde/daily_report_3.jpg"
											alt="WhereShouldWeGo sequence_diagram_stomp" loading="lazy">
									</figure>
									<ul class="ul">
										<li><b>KPI 패널</b>: 일간 기사 수, 전일 대비(DoD), 카테고리 다양성, 최상위 키워드로 핵심 지표 제공.</li>
										<li><b>최근 14일 추이(Line)</b>: 일별 기사량 변화를 선그래프로 표시.</li>
										<li><b>시간대 분포(Bar)</b>: 0–23시 기사 발생량 분포를 막대로 표시.</li>
										<li><b>키워드 TOP 10(Bar)</b>: 빈도 기준 상위 키워드 제공.</li>
										<li><b>카테고리 TOP 10(H-Bar)</b>: 상위 카테고리와 건수 정리.</li>
										<li><b>키워드 Word Cloud</b>: 당일 핵심 단어를 시각적으로 강조.</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>매일 아침 자동 생성·배포로 전날 뉴스를 빠르게 파악할 수 있습니다.</li>
										<li>KPI, 추이, 분포, 키워드, 카테고리, 워드클라우드 등 <b>6개 시각화</b>를 한눈에 제공합니다.</li>
										<li>생성부터 발송까지 <b>약 5분 이내</b> 완료됩니다.</li>
									</ul>
								</div>
							</details>

							<details>
								<summary><b>3.4. 파이프라인 단순화를 위한 리팩토링</b></summary>
								<div class="content">
									<h4>배경</h4>
									<ul class="ul">
										<li>초기 명세서에서는 Kafka로 수집한 데이터를 <b>PyFlink</b>가 처리한 뒤, 결과를
											<b>PostgreSQL·Elasticsearch·Hadoop(HDFS)</b>에 저장하고 Spark + Matplotlib으로 리포트를
											생성하는 구조였습니다.
										</li>
										<li>하지만 실제 운영 환경에서는 Flink와 Hadoop은 학습 곡선이 높고 리소스 요구량도 커, 안정적으로 유지·확장하기
											어려웠습니다.</li>
										<li>따라서 프로젝트의 <b>운영 단순화와 유지보수성</b>을 위해 불필요하게 복잡한 구성 요소를 제거하는 리팩토링이 필요했습니다.</li>
									</ul>

									<h4>도전</h4>
									<ul class="ul">
										<li>Flink와 Hadoop을 제거하면 실시간 처리·대용량 저장에서의 기능 손실이 발생할 수 있어, 이를 대체할 방안을 찾아야 했습니다.
										</li>
										<li>리포트 생성에 필요한 집계·분석을 <b>PostgreSQL 단독</b>으로 처리할 수 있는지 검증해야 했습니다.</li>
										<li>데이터 아카이빙을 HDFS가 아닌 <b>경량화된 방식</b>으로 전환하면서도 분석 결과 관리 체계를 유지해야 했습니다.</li>
									</ul>

									<h4>해결 방안</h4>
									<ul class="ul">
										<li><b>PyFlink 제거</b>
											<ul>
												<li>Kafka에서 소비한 데이터를 Flink 대신 <b>Python Consumer</b>가 직접 처리하여
													PostgreSQL과 Elasticsearch에 저장하도록 단순화하였습니다.</li>
												<li>이로써 Flink 운영·학습 부담을 줄이고, 메시지 파이프라인 지연을 단축하였습니다.</li>
											</ul>
										</li>
										<li><b>Hadoop(HDFS) 제거</b>
											<ul>
												<li>대용량 분산 스토리지가 꼭 필요하지 않은 서비스 특성을 고려하여, HDFS 대신 <b>PostgreSQL</b>을 데이터
													저장소로 일원화하였습니다.</li>
												<li>리포트 생성을 위해 Spark가 PostgreSQL JDBC를 통해 데이터를 읽어오도록 변경하였습니다.</li>
											</ul>
										</li>
										<li><b>리포트 아카이빙 경량화</b>
											<ul>
												<li>생성된 PDF 리포트를 HDFS에 보관하지 않고, <b>Local Archive 디렉토리</b>에 저장하도록
													변경하였습니다.</li>
												<li>필요 시 외부 저장소로 이관 가능하도록 경로 설정만 추가하였습니다.</li>
											</ul>
										</li>
										<li><b>Docker Compose 단순화</b>
											<ul>
												<li>Flink 및 HDFS 관련 컨테이너를 제거하여 전체 Compose 구성이 가벼워지고, 리소스 사용량이 크게
													줄어들었습니다.</li>
											</ul>
										</li>
									</ul>

									<h4>성과</h4>
									<ul class="ul">
										<li>Docker Compose 서비스 구성이 단순화되어 <b>컨테이너 수가 약 30% 감소</b>, 로컬 개발 환경 구동 시간이
											단축되었습니다.</li>
										<li>Flink와 Hadoop 제거로 학습·운영 부담이 줄어, 팀원들이 보다 익숙한
											<b>PostgreSQL·Elasticsearch·Spark</b> 중심으로 개발할 수 있게 되었습니다.
										</li>
										<li>리포트 생성 프로세스는 유지하면서도, 데이터 경로와 관리 방식이 간소화되어 <b>운영 효율성과 안정성</b>이 향상되었습니다.</li>
									</ul>
								</div>
							</details>


						</div>
					</div>
				</div>


				<!-- 7. 회고 -->
				<div class="wrapper5">
					<b class="b">
						<ol class="ol" start="4">
							<li>회고</li>
						</ol>
					</b>
					<div class="divider">
						<div class="min-height"></div>
						<div class="divider1"></div>
					</div>
					<div class="contents-wrapper">
						<div class="div">
							<ul class="ul">
								<li><b>단일 토픽 기반 파이프라인</b>으로 운영 단순성을 얻었지만, 향후 토픽 세분화 필요성을 느꼈습니다.</li>
								<li><b>이중 저장 전략</b>을 직접 구현하면서 DB↔ES 정합성 유지의 어려움을 체감했고, CDC 도입 필요성을 인식했습니다.</li>
								<li><b>Spark+Airflow</b> 리포트 자동화로 운영 효율을 크게 개선했지만, 리소스 사용량 최적화는 추가 과제입니다.</li>
								<li>실시간성과 배치 분석을 함께 설계하며 <b>데이터 파이프라인 전주기 경험</b>을 쌓을 수 있었습니다.</li>
							</ul>
						</div>
					</div>
				</div>

			</div>

			<!-- 하단 버튼 -->
			<div class="btn-wrapper">
				<div class="button" id="buttonContainer" data-href="../../index.html" role="link" tabindex="0"
					aria-label="목록으로 돌아가기">
					<img class="phosphor-icons-users" alt="" src="/assets/caret_left_icon.svg">
					<div class="button1">돌아가기</div>
				</div>
			</div>
		</div>
	</div>
	<div class="sticky">
		<div class="text-wrapper">
			<div class="div7">협업은 부드럽게, 기준은 단단하게.</div>
			<b class="b8">신입 데이터 엔지니어 황동혁입니다.</b>
		</div>
		<div class="wrapper12">
			<div class="button2" id="buttonContainer" data-href="../../index.html" role="link">
				<img class="phosphor-icons-caretleft1" alt="" src="/assets/caret_left_icon.svg">
			</div>
			<b class="b9">프로젝트 상세보기</b>
		</div>
	</div>

	<script>
		document.querySelectorAll('[id="buttonContainer"]').forEach((btn) => {
			const url = btn.dataset.href || './index.html';
			const go = () => { window.location.href = url; };
			btn.addEventListener('click', go);
			btn.addEventListener('keydown', (e) => {
				if (e.key === 'Enter' || e.key === ' ') {
					e.preventDefault();
					go();
				}
			});
		});

		(function () {
			// 오버레이 DOM 생성
			const overlay = document.createElement('div');
			overlay.className = 'lightbox-overlay';
			overlay.innerHTML = `
    <div class="lightbox-content" tabindex="-1" role="dialog" aria-modal="true">
      <button class="lightbox-close" aria-label="닫기">✕</button>
    </div>
  `;
			document.body.appendChild(overlay);

			const content = overlay.querySelector('.lightbox-content');
			const closeBtn = overlay.querySelector('.lightbox-close');

			function getVideoSrc(el) {
				const s = el.querySelector('source');
				return (s && s.src) || el.currentSrc || el.src;
			}

			function openLightbox(el) {
				// 기존 미디어 제거
				content.querySelectorAll('img,video').forEach(n => n.remove());

				let node;
				if (el.tagName.toLowerCase() === 'img') {
					node = document.createElement('img');
					node.src = el.src;
					node.alt = el.alt || '';
				} else {
					node = document.createElement('video');
					node.src = getVideoSrc(el);
					node.autoplay = true;
					node.loop = true;
					node.muted = true;
					node.playsInline = true;
					node.controls = true;
				}

				content.appendChild(node);
				overlay.style.display = 'flex';
				document.body.classList.add('lb-open');
				content.focus();
			}

			function closeLightbox() {
				overlay.style.display = 'none';
				document.body.classList.remove('lb-open');
				content.classList.remove('cover'); // cover 모드 해제
				const v = content.querySelector('video');
				if (v) { try { v.pause(); } catch (e) { } }
			}

			// 위임 클릭으로 열기
			document.addEventListener('click', (e) => {
				const t = e.target.closest('.lightboxable');
				if (t) {
					e.preventDefault();
					openLightbox(t);
				}
			});

			// 배경 클릭으로 닫기
			overlay.addEventListener('click', (e) => {
				if (e.target === overlay) closeLightbox();
			});

			closeBtn.addEventListener('click', closeLightbox);

			// ESC 닫기
			document.addEventListener('keydown', (e) => {
				if (overlay.style.display === 'flex' && e.key === 'Escape') closeLightbox();
			});

			// Z 키 or 미디어 클릭으로 contain ↔ cover 전환
			function toggleFitMode() {
				content.classList.toggle('cover');
			}

			content.addEventListener('click', (e) => {
				const media = e.target.closest('img,video');
				if (media) toggleFitMode();
			});

			document.addEventListener('keydown', (e) => {
				if (overlay.style.display === 'flex' && (e.key === 'z' || e.key === 'Z')) {
					toggleFitMode();
				}
			});
		})();
	</script>
</body>

</html>